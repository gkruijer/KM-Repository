<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>Actions</key>
		<array>
			<dict>
				<key>ActionColor</key>
				<string>Yellow</string>
				<key>ActionUID</key>
				<integer>16271809</integer>
				<key>MacroActionType</key>
				<string>Comment</string>
				<key>StyledText</key>
				<data>
							cnRmZAAAAAADAAAAAgAA
							AAcAAABUWFQucnRmAQAA
							AC5aAgAAKwAAAAEAAABS
							AgAAe1xydGYxXGFuc2lc
							YW5zaWNwZzEyNTJcY29j
							b2FydGYyNzA5Clxjb2Nv
							YXRleHRzY2FsaW5nMFxj
							b2NvYXBsYXRmb3JtMHtc
							Zm9udHRibFxmMFxmc3dp
							c3NcZmNoYXJzZXQwIEhl
							bHZldGljYS1Cb2xkO1xm
							MVxmc3dpc3NcZmNoYXJz
							ZXQwIEhlbHZldGljYTt9
							CntcY29sb3J0Ymw7XHJl
							ZDI1NVxncmVlbjI1NVxi
							bHVlMjU1O30Ke1wqXGV4
							cGFuZGVkY29sb3J0Ymw7
							O30KXHBhcmRcdHg1NjBc
							dHgxMTIwXHR4MTY4MFx0
							eDIyNDBcdHgyODAwXHR4
							MzM2MFx0eDM5MjBcdHg0
							NDgwXHR4NTA0MFx0eDU2
							MDBcdHg2MTYwXHR4Njcy
							MFxwYXJkaXJuYXR1cmFs
							XHBhcnRpZ2h0ZW5mYWN0
							b3IwCgpcZjBcYlxmczI4
							IFxjZjAgTmFtZQpcZjFc
							YjAgOiBNSU0gLSBQcm9t
							cHRcCgpcZjBcYiBWZXJz
							aW9uClxmMVxiMCA6IDEu
							MFwKClxmMFxiIFVwZGF0
							ZWQKXGYxXGIwIDogMjAy
							NC8xMS8xOCAwMzo1MCBQ
							VFwKClxmMFxiIEJ5Clxm
							MVxiMCA6IERhbiBUaG9t
							YXNcClwKClxmMFxiIFBV
							UlBPU0UKXGYxXGIwIDpc
							ClwKU2hvd3MgdGhlIFBy
							b21wdCB3aW5kb3cuXApc
							CgpcZjBcYiBWRVJTSU9O
							IEhJU1RPUlkKXGYxXGIw
							IDpcCjEuMCAtIEluaXRp
							YWwgdmVyc2lvbi59AQAA
							ACMAAAABAAAABwAAAFRY
							VC5ydGYQAAAAkCo7Z7YB
							AAAAAAAAAAAAAA==
							</data>
				<key>Title</key>
				<string>MIM - Prompt v1.0</string>
			</dict>
			<dict>
				<key>ActionName</key>
				<string>Local License and Disclaimer</string>
				<key>ActionUID</key>
				<integer>16271810</integer>
				<key>IsActive</key>
				<false/>
				<key>IsDisclosed</key>
				<false/>
				<key>MacroActionType</key>
				<string>SetVariableToText</string>
				<key>Text</key>
				<string>Copyright (c) Daniel Thomas

Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
</string>
				<key>Variable</key>
				<string>Local License and Disclaimer</string>
			</dict>
			<dict>
				<key>ActionColor</key>
				<string>Magenta</string>
				<key>ActionUID</key>
				<integer>16271716</integer>
				<key>Asynchronously</key>
				<false/>
				<key>IsDisclosed</key>
				<false/>
				<key>MacroActionType</key>
				<string>ExecuteMacro</string>
				<key>MacroUID</key>
				<string>CFC5CDB0-8E5C-489C-B185-040B3957FA5B</string>
				<key>TimeOutAbortsMacro</key>
				<true/>
				<key>UseParameter</key>
				<true/>
			</dict>
			<dict>
				<key>ActionColor</key>
				<string>Green</string>
				<key>ActionName</key>
				<string>Show the Custom HTML Prompt</string>
				<key>ActionUID</key>
				<integer>16273585</integer>
				<key>Conditions</key>
				<dict>
					<key>ConditionList</key>
					<array>
						<dict>
							<key>ConditionType</key>
							<string>Variable</string>
							<key>Variable</key>
							<string>Instance_HtmlFilePath</string>
							<key>VariableConditionType</key>
							<string>IsNotEmpty</string>
							<key>VariableValue</key>
							<string>value</string>
						</dict>
					</array>
					<key>ConditionListMatch</key>
					<string>All</string>
				</dict>
				<key>ElseActions</key>
				<array>
					<dict>
						<key>ActionName</key>
						<string>Embedded MIM - Prompt.html</string>
						<key>ActionUID</key>
						<integer>15817932</integer>
						<key>Floating</key>
						<true/>
						<key>IsDisclosed</key>
						<false/>
						<key>MacroActionType</key>
						<string>CustomPrompt</string>
						<key>Resizable</key>
						<true/>
						<key>Text</key>
						<string>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
	&lt;meta charset="UTF-8"&gt;
	&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
	&lt;title&gt;MIM - Macro Import Manager&lt;/title&gt;
&lt;style type="text/css"&gt;
body {
    font-family: Arial, sans-serif;
	font-size: 14px;
    margin: 20px;
    display: flex;
    flex-direction: column;
    margin: 0;
    height: 100vh;
	background-color: #ececec;
    overflow: hidden;
}

#documentHeader {
    padding: 15px;
	padding-bottom: 10px;
    flex: 0 0 auto;
    border-bottom: 1px solid #a5a5a5;
	display: flex;
	flex-direction: row;
	align-items: center;
	gap: 1px;
}

#titleGroup {
	flex: 0 0 auto;
	display: flex;
	flex-direction: row;
	align-items: center;
	gap: 0;
}

#documentFooter {
    margin: 10px;
	margin-top: auto;
    padding-top: 10px;
    flex: 0 0 auto;
    gap: 5px;
    border-top: 1px solid #a5a5a5;
    display: flex;
    flex-direction: row;
	align-items: center;
}

#documentHeader .spacer,
#documentFooter .spacer {
    flex: 1 1 auto;
	text-align: center;
}

#tipSpacer {
	font-size: 12px;
	pointer-events: none;
	/* opacity: 0;
	transition: opacity .5s ease; */
}

#titleIcon {
	flex: 0 0 auto;
	margin-right: 3px;
}

#title {
	font-size: 1.5em;
	font-weight: bold;
	flex: 0 0 auto;
}

#titleModified {
	margin-left: 10px;
	flex: 0 0 auto;
	font-size: 1em;
	font-weight: bold;
	color: red;
}

.hidden {
	display: none !important;
}

.modified {
	font-style: italic;
}

.client-container {
	display: flex;
	flex-direction: column;
	margin: 0 10px;
	background-color: #ececec;
    overflow-y: auto;
}

.client-container-startup {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	display: flex;
	flex-direction: column;
	margin: 0 10px;
	background-color: #ececec;
    overflow-y: auto;
}


#macroListContainer {
	margin-right: 20px;
}

.groupItemContainer,
.macroItemContainer {
	display: flex;
	flex-direction: row;
}

/* .groupItemContainer:hover
.macroItemContainer {
	display: flex;
	flex-direction: row;
} */

.groupNameDiv:hover {
	cursor: default;
}

.groupItemContainer {
	flex: 1;
	display: flex;
	flex-direction: row;
	margin-left: 10px;
	margin-right: 10;
	margin-top: 20px;
	margin-bottom: 4px;
	/* color: blue; */
}

/* #region ======== editNameButton undoNameButton =========== */

.nameButton {
	flex: 0 0 auto;
	padding-left: 2px;
	cursor: pointer;
	transition: opacity .5s ease;
}

.nameButtonHidden {
	opacity: 0;
}

.helpNameButton {
	margin-left: 5px;
	transform: scale(1.5) translateY(-1px);
}

.editNameButton {
	margin-left: 10px;
	transform: scale(1.5);
}

.undoNameButton {
	margin-left: 14px;
	transform: scale(1.5) translateY(-1px);
	display: none;
}

.nameButtonContents {
	transform: translateY(2px);
}

.nameButton svg {
	transition: transform 0.2s ease;
}

.nameButton:hover svg {
	transform: scale(1.2);
	/* transform-origin: center left; */
}

.nameButton:active svg {
	transform: scale(1.2) translateY(1px);
}

/* #endregion */

/* #region ======== editableDiv ============================= */

.editableDiv {
	flex: 0 0 auto;
	display: flex;
	max-width: calc(100% - 40px);
	user-select: none;
	-webkit-user-select: none;
	overflow-x: hidden;
	overflow-wrap: anywhere;
}

.editableDiv &gt; input {
	font-size: 1em;
	flex: 1;
	width: 100%;
	height: 100;
	background-color: inherit;
}

.editableDivContainer.somethingsEditing .custom-checkbox-container,
.editableDivContainer.somethingsEditing .editableDivContent,
.editableDivContainer.somethingsEditing a {
	pointer-events: none;
	text-decoration: none;
	color: gray;
}

.editableDivContainer.somethingsEditing .custom-checkbox-container {
	opacity: 0.5
}

.editableDivContainer.somethingsEditing .nameButton {
	display: none;
}

.editableDivContainer:hover:not(.somethingsEditing):has(.editableDiv:hover, .nameButton:hover) .nameButton {
	opacity: 1;
}

.editableDivContainer:hover:not(.somethingsEditing):has(.editableDiv:hover) .editableDivContent.noLink {
	cursor: default;
}

.editableDiv.editing {
	padding-left: 2px;
	padding-right: 2px;
	user-select:auto;
	-webkit-user-select: auto;
	cursor: default;
	flex: 1;
	transform: translateY(-4px);
}

.editableDivContainer.somethingsEditing:has(.editableDiv.modified) &gt; .undoNameButton {
	display: none;
}

.editableDiv.modified:not(.somethingsEditing) ~ .undoNameButton {
	display: block;
}

/* #endregion */

/* #region ======== icons =================================== */

.iconDiv {
	margin-right: 5px;
}

.iconDiv svg {
	width: 18px;
	height: 18px;
	transform: translateY(-2px);
}

.iconImg {
	width: 18px;
	height: 18px;
	transform: translateY(-2px);
}

.groupItemContainer .iconDiv .iconImg {
	transform: translateY(-1px);
}

#titleIcon .iconImg {
	width: 24px;
	height: 24px;
	transform:translateY(1px);
}


/* #endregion */

/* #region ======== custom-checkbox ========================= */

.custom-checkbox-container {
	flex: 0;
	margin-right: 10px;
}

.custom-checkbox {
    display: none;
}

.custom-checkbox-label {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 1px solid black;
    border-radius: 3px;
    position: relative;
    cursor: pointer;
    transition: background-color 0.3s, border-color 0.3s;
}

.custom-checkbox:checked + .custom-checkbox-label {
    background-color: #4caf50;
    border-color: #4caf50;
}

.custom-checkbox:checked + .custom-checkbox-label::after {
    content: '';
    position: absolute;
    top: 1px;
    left: 4px;
    width: 4px;
    height: 8px;
    border: solid white;
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
}

.custom-checkbox-label:hover {
    border-color: #888;
}

/* #endregion */

/* #region ======== checkbox-list =========================== */

.checkbox-list {
    list-style-type: none;
    margin: 5px 20px;
    padding: 0;
}

.checkbox-list li {
    /* margin: 0; */
    padding: 5px;
}

.checkbox-list .label {
	white-space: nowrap;
}

.checkbox-list .checkbox {
	margin-right: 10px;
}

/* #endregion */

/* #region ======== Dialog ================================== */

#modalDialog {
    border: 1px solid lightslategray;
    border-radius: 6px;
    box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
    padding: 0;
    background-color: #ececec;
    max-width: 90%;
	width: 90%;
}

#modalDialog.contentSize {
    width: min-content;
}

#modalDialog::backdrop {
	background: rgba(0, 0, 0, 0.3);
}

#modalDialog:not([open]) {
	pointer-events: none;
	opacity: 0;
}

#modalDialogContainer {
	left: 0;
	top: 0;
    display: flex;
    flex-direction: column;
}

#modalDialog.contentSize #modalDialogContainer {
	width: min-content;
	height: min-content;
}

#modalDialogHeader {
	flex: 0 0 auto;
	display: flex;
	flex-direction: row;
	align-items: center;
	border-bottom: 1px solid #a5a5a5;
	padding: 7px 5px 5px 10px;
	font-weight: bold;
	font-size: 1.1em;
}

.modalDialogIcon {
	font-size: 1.2em;
	margin-right: 5px;
}

#modalDialogMessage {
	flex: 0 0 auto;
	padding: 10px 20px;
    /* margin-bottom: 10px; */
    font-size: 14px;
}

#modalDialog.contentSize #modalDialogMessage {
    white-space: nowrap;
}

#modalDialogMessage &gt; p {
	line-height: 16px;
}

.modalDialogNameValueTable {
	border-collapse: collapse;
}

.modalDialogNameValueTable tr:nth-child(odd) {
	background-color: #e0f7e0;
}

.modalDialogNameValueTable tr:nth-child(even) {
	background-color: #c3e6c3;
}

.modalDialogNameValueTable td {
	border: 1px solid #ccc;
	padding: 8px;
	text-align: left;
}

.modalDialogNameValueTable td.diffValue {
	color: red
}

.modalDialogNameValueTable td:first-child{
	font-weight: bold;
	padding-right: 5px;
}

.modalDialogNameValueTable td:nth-child(2){
	font-family: Consolas, monospace;
	padding-right: 5px;
}

.modalDialogFooter {
	flex: 0;
    display: flex;
	flex-direction: row;
	justify-content: flex-end;

	/* margin-top: auto; */
    padding: 8px 10px;
    flex: 0 0 auto;
    gap: 10px;
    border-top: 1px solid #a5a5a5;

}

.modalDialogFooter a {
	min-width: 39px;
}

/* #endregion */

/* #region ======== popup-menu ============================ */

.popup-menu {
	position: absolute;
	text-align: left;
	z-index: 9999;

	font-family: Verdana, Geneva, Tahoma, sans-serif;
	background: #ececec !important;
	font-size: 13px !important;
	border-radius: 8px !important;
	border-color: #d6d6d6 !important;
	padding: 4px 4px !important;
	box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.4) !important;
	visibility:visible
}

.popup-menu.invisible {
	visibility: collapse;
}

.popup-menu ul {
	padding: 0px;
	margin: 0px;
	list-style: none;
}

.popup-menu ul li {
	padding-top: 3px;
	padding-bottom: 3px;
	padding-left: 10px;
	padding-right: 10px;
	color: black;
}

.popup-menu ul li.popup-menu-separator {
	padding-top: 1px;
	padding-bottom: 0;
	padding-left: 6px;
	padding-right: 6px;
	pointer-events: none;
}

.popup-menu ul li:not(.popup-menu-separator):hover {
	cursor: default;
	color: #fff !important;
	background: #1D68CD !important;

}

/* #endregion */

/* #region ======== Toast ======================== */

.toast {
    position: absolute;
    top: 15px;
    right: 20px;
	z-index: 99999;
    border-radius: 12px;
	border: 1px solid #84bbf3;
    padding: 15px 35px 15px 25px;
    box-shadow: 0 6px 20px -5px rgba(0, 0, 0, 1);
    overflow: hidden;
    transform: translateX(calc(100% + 40px));
    transition: all 1s cubic-bezier(0.68, -0.55, 0.265, 1.35);
}

.toast.toast-scheme-success {
    background: #e9f9e8;
	color: black;
}

.toast.toast-scheme-info {
    background: #e8f0f9;
	color: black;
}

.toast.toast-scheme-warning {
    background: #fff2cd;
	color: black;
}

.toast.toast-active {
	transform: translateX(0%);
}

.toast .toast-content {
    display: flex;
    align-items: center;
}

.toast-content .toast-message {
    display: flex;
    flex-direction: column;
    margin: 0 20px;
}

.toast-content &gt; img {
	width: 30px;
	height: 30px;
}

.toast-message .toast-text {
    font-size: 14px;
    font-weight: 400;
    color: #666666;
}

.toast-message .toast-text.toast-title-text {
    font-weight: 600;
    color: #333;
}

.toast-close {
	position: absolute;
	right: 10px;
	top: 10px;
	width: 16px;
	height: 16px;
	opacity: 0.3;
}
.toast-close:hover {
	opacity: 1;
}
.toast-close:before, .toast-close:after {
	position: absolute;
	left: 8px;
	content: ' ';
	height: 16px;
	width: 2px;
	background-color: #333;
}
.toast-close:before {
	transform: rotate(45deg);
}
.toast-close:after {
	transform: rotate(-45deg);
}

.toast .toast-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 3px;
    width: 100%;
}

.toast .toast-progress:before {
    content: "";
    position: absolute;
    bottom: 0;
    right: 0;
    height: 100%;
    width: 100%;
    background-color: #4070f4;
}

.toast-progress.toast-active:before {
    animation: toast-progress 4s linear forwards;
}

@keyframes toast-progress {
    100% {
      	right: 100%;
    }
}

/* #endregion */

/* #region ======== Buttons ================================= */

.button {
    border-radius:6px;
	display:inline-block;
	cursor:pointer;
    font-family: Helvetica, sans-serif;
	font-size:12px;
	font-weight:bold;
	padding:6px 13px;
	text-decoration:none;
	text-align: center;
}

.button:active {
	position:relative;
	top:1px;
}

.button:focus {
	outline: none;
}

#selectAllButton {
	box-shadow:inset 0px 1px 0px 0px #caefab;
	background:linear-gradient(to bottom, #77d42a 5%, #5cb811 100%);
	background-color:#77d42a;
	border:1px solid #268a16;
	color:#306108;
	text-shadow:0px 1px 0px #aade7c;
}
#selectAllButton:hover {
	background:linear-gradient(to bottom, #5cb811 5%, #77d42a 100%);
	background-color:#5cb811;
}

#unselectAllButton {
	box-shadow:inset 0px 1px 0px 0px #fff6af;
	background:linear-gradient(to bottom, #ffec64 5%, #ffab23 100%);
	background-color:#ffec64;
	border:1px solid #ffaa22;
	color:#333333;
	text-shadow:0px 1px 0px #ffee66;
}

#unselectAllButton:hover {
	background:linear-gradient(to bottom, #ffab23 5%, #ffec64 100%);
	background-color:#ffab23;
}

.acceptButton {
	box-shadow:inset 0px 1px 0px 0px #97c4fe;
	background:linear-gradient(to bottom, #3d94f6 5%, #1e62d0 100%);
	background-color:#3d94f6;
	border:1px solid #337fed;
	color:#ffffff;
	/* text-shadow:0px 1px 0px #1570cd; */
}

.acceptButton:hover {
	background:linear-gradient(to bottom, #1e62d0 5%, #3d94f6 100%);
	background-color:#1e62d0;
}

.acceptButton.disabled {
	cursor: not-allowed !important;
	pointer-events: none !important;
	background: rgb(114, 113, 113) !important;
	border:1px solid #a5a5a5;
	opacity: 0.5;
}

.cancelButton {
	box-shadow:inset 0px 1px 0px 0px #ffffff;
	background:linear-gradient(to bottom, #f9f9f9 5%, #e9e9e9 100%);
	background-color:#f9f9f9;
	border:1px solid #dcdcdc;
	color:#666666;
	text-shadow:0px 1px 0px #ffffff;
}

.cancelButton:hover {
	background:linear-gradient(to bottom, #e9e9e9 5%, #f9f9f9 100%);
	background-color:#e9e9e9;
}

/* #endregion */
&lt;/style&gt;
&lt;script type="text/javascript"&gt;
'use strict';

var _errorOccurred = false;

Node.prototype.swapClass = function(className1, className2, useClassName1) {
	if (useClassName1) {
		this.classList.remove(className2);
		this.classList.add(className1)
	} else {
		this.classList.remove(className1);
		this.classList.add(className2)
	}
}

Node.prototype.isDescendant = function(parent) {
	var node = this.parentNode;
    while (node) {
        if (node === parent)
            return true;
        node = node.parentNode;
    }
	return false;
}

Node.prototype.setHidden = function (hide) {
	return this.classList.toggle("hidden", hide);
}

Node.prototype.isHidden = function () {
	return this.hasClass("hidden");
}

String.prototype.toInitialCaps = function () {
	return `${this.charAt(0).toUpperCase()}${this.slice(1).toLowerCase()}`;
}

function getStack(e) {
	try {
		var stack = e.stack.split("\n");
		return stack.map(l =&gt; {
			l = l.replaceAll("%20", " ");
			const i = l.lastIndexOf("/");
			if (i &lt; 0)
				return l;
			return l.substring(i+1);
		}).join("\n");
	} catch (e) {
		return `Error retrieving stack: ${e}`;
	}
}

function handleError(e) {
	if (e.errorWasHandled)
		return;
	e.errorWasHandled = true;
	if (!_errorOccurred) {
		_errorOccurred = true;
		setTimeout(() =&gt; KM.cancel(`Error: ${e}; Stack:\n${getStack(e)}`), 100);
		console.error(e);
	}
}

function deepClone(obj) {
	return JSON.parse(JSON.stringify(obj));
}

function parseBoundsString(s, desc) {
	const matches = /^(\d+),\s*(\d+),\s*(\d+),\s*(\d+)$/.exec(s);
	if (!matches)
		throw new Error(`${desc} ("${s}") must contain 4 numbers separated by commas`);
	return {
		left: parseInt(matches[1]),
		top: parseInt(matches[2]),
		width: parseInt(matches[3]),
		height: parseInt(matches[4])
	}
}

function coerceArray(obj) {
	return Array.isArray(obj) ? obj : [obj];
}

function replaceMultipleSpacesWithNbsp(text) {
    return text.replace(/ {2,}/g, function(match) {
        return '&amp;nbsp;'.repeat(match.length);
    });
}

function escapeHTML(text) {
	const map = {
		'&amp;': '&amp;amp;',
		'&lt;': '&amp;lt;',
		'&gt;': '&amp;gt;',
		'"': '&amp;quot;',
		"'": '&amp;#039;'
	};
	return text.replace(/[&amp;&lt;&gt;"']/g, m =&gt; map[m]);
}

class KM {
	static close = (msg) =&gt; window.KeyboardMaestro.Submit(msg);
	static cancel = (msg) =&gt; window.KeyboardMaestro.Cancel(msg);
	static getVariable = (name, required) =&gt; {
		var result;
		if (name.startsWith("Local_"))
			result = document.kmvar[name] || "";
		else
			result = window.KeyboardMaestro.GetVariable(name);
		if (required &amp;&amp; !result)
			throw new Error(`Variable "${name}" is required`);
		return result;
	}

	static getIntVariable = (name, required, options) =&gt; {
		options = options ?? {};
		var result = this.getVariable(name, required);
		if (result === "")
			return options.defaultValue ?? null;
		const regex = options.allowNegatives ? /^-?\d+$/ : /^\d+$/;
		if (regex.test(result))
			return parseInt(result);
		throw new Error(`Variable "${name}" (${result}) is not an integer${options.allowNegatives ? "" : " &gt;= 0"}`);
	}
	static getJSONVariable = (name, required) =&gt; {
		var result = KM.getVariable(name, required);
		if (!result)
			return;
		try {
			return JSON.parse(result)
		} catch (e) {
			throw new Error(`Error parsing JSON for variable ${name}: ${e.message}`);
		}
	}
	static setVariable = (name, value) =&gt; window.KeyboardMaestro.SetVariable(name, value);
	static jsonStringify(obj, pretty) {
		const replacer = (key, value) =&gt; {
			if (value == null)
				return undefined;
			if (value === true)
				return "1";
			if (value === false)
				return "0";
			return value;
		};
		const space = pretty == null || pretty === true ? 2 : null;
		return JSON.stringify(obj, replacer, space);
	}
	static getNewUUID = () =&gt; this.processTokens("%RandomUUID%");
	static getKMWindowId = () =&gt; document.querySelector("body").dataset.kmwindowid;
	static processTokens = (token) =&gt; window.KeyboardMaestro.ProcessTokens(token);
	static trigger = (macro, param) =&gt; window.KeyboardMaestro.Trigger(macro, param);
	static calculate = s =&gt; parseInt(window.KeyboardMaestro.Calculate(s));
	static get screenLeft() {return KM.calculate("SCREENVISIBLE(Main, Left)");}
	static get screenTop() {return KM.calculate("SCREENVISIBLE(Main, Top)");}
	static get screenWidth() {return KM.calculate("SCREENVISIBLE(Main, Width)");}
	static get screenHeight() {return KM.calculate("SCREENVISIBLE(Main, Height)");}
	static get windowLeft() {return KM.calculate("WINDOW(Left)");}
	static get windowTop() {return KM.calculate("WINDOW(Top)");}
	static get windowWidth() {return KM.calculate("WINDOW(Width)");}
	static get windowHeight() {return KM.calculate("WINDOW(Height)");}
}

class DocumentEventListeners {


	#listeners = [];

	constructor(listeners) {
		this.add(listeners);
	}

	add(listener) {
		coerceArray(listener).forEach((l) =&gt; {
			this.#listeners.push({
				eventName: l.eventName,
				handler: l.handler,
				groupName: l.groupName
			});
		})
	}

	attach(groupName) {
		this.#listeners.filter(l =&gt; !groupName || l.groupName === groupName)
			.forEach(l =&gt; document.addEventListener(l.eventName, l.handler));
	}

	detach(groupName) {
		this.#listeners.filter(l =&gt; !groupName || l.groupName === groupName)
			.forEach(l =&gt; document.removeEventListener(l.eventName, l.handler));
	}
}

const KeyCodes = {
	// https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
	escape: "Escape",
	enter: "Enter"
}

class KeyCode {
	key;
	altKey;
	ctrlKey;
	metaKey;
	shiftKey;

	static matches(keyCodes, targetKeyCode) {
		return this.findMatch(keyCodes, targetKeyCode) != null;
	}

	static modifierKeysMatch(keyCodes, targetKeyCode) {
		return this.findMatch(keyCodes, targetKeyCode, {modifierKeysOnly: true}) != null;
	}

	static toString(keyCode) {
		function boolValue(propName) {
			if (Boolean(keyCode[propName]))
				return ` ${propName}`;
			return "";
		}

		return `${keyCode.key ?? ""}${boolValue("altKey")}${boolValue("ctrlKey")}${boolValue("metaKey")}${boolValue("shiftKey")}`;
	}

	static findMatch(keyCodes, targetKeyCode, options) {
		options = options ?? {};
		return coerceArray(keyCodes).find(keyCode =&gt; {
			const result = (
				(options.modifierKeysOnly || keyCode.key === targetKeyCode.key)
				&amp;&amp; (Boolean(keyCode.altKey)   === Boolean(targetKeyCode.altKey))
				&amp;&amp; (Boolean(keyCode.ctrlKey)  === Boolean(targetKeyCode.ctrlKey))
				&amp;&amp; (Boolean(keyCode.metaKey)  === Boolean(targetKeyCode.metaKey))
				&amp;&amp; (Boolean(keyCode.shiftKey) === Boolean(targetKeyCode.shiftKey))
			);

			return result;
		});
	}
}

var _documentKeydownHandler;

class DocumentKeydownHandler {


	#listeners = [];

	#nextId = 1;

	#escapeClosesWindow = false;

	constructor() {
	}

	attach() {
		document.onkeydown = (e) =&gt; this.#keydownHandler(e);
	}

	addListener(keyCodes, handler) {
		try {
			if (!keyCodes)
				throw new Error(`keyCodes is required`);
			if (!Array.isArray(keyCodes))
				keyCodes = [keyCodes];
			if (keyCodes.length === 0)
				throw new Error(`keyCodes is required`);

			const id = this.#nextId++;
			this.#listeners.push({
				id: id,
					keyCodes: deepClone(keyCodes),
				handler: handler
			});
			return id;
		} catch (e) {
			handleError(e);
		}
	}

	removeListener(id) {
		this.#listeners = this.#listeners.filter(l =&gt; l.id !== id);
	}

	#keydownHandler(e) {

		const handledKey = () =&gt; {
			e.stopPropagation();
			e.preventDefault;
			return false;
		}

		try {
			const handled = this.#listeners.find(l =&gt; {
				const keyCode = KeyCode.findMatch(l.keyCodes, e);
				if (!keyCode)
					return false;
				return l.handler(e, keyCode);
			});

			if (handled)
				return handledKey();

			if (KeyCode.matches({key: KeyCodes.escape}, e)) {
				if (ModalDialogController.isOpen) {
					ModalDialogController.closeDialog(false);
					return handledKey();
				}
				if (this.#escapeClosesWindow)
					return;
				return handledKey();
			}
			if (KeyCode.matches({key: "q", metaKey: true}, e)) {
				KM.close("cancel");
				return handledKey();
			}
		} catch (e) {
			handleError(e);
			return handledKey();
		}
	}
}

class ModalDialogController {
	static #dialog;
	static #dialogIconInformation;
	static #dialogIconConfirmation;
	static #dialogTitle;
	static #dialogMessage;
	static #confirmButton;
	static #cancelButton;

	static attach() {
		this.#dialog = document.getElementById("modalDialog");
		this.#dialogIconInformation = document.getElementById("modalDialogIcon_information");
		this.#dialogIconConfirmation = document.getElementById("modalDialogIcon_confirmation");
		this.#dialogTitle = document.getElementById("modalDialogTitle");
		this.#dialogMessage = document.getElementById("modalDialogMessage");
		this.#confirmButton = document.getElementById("modalDialogConfimButton");
		this.#confirmButton.addEventListener("click", () =&gt; this.#dialog.close("confirm"));
		this.#cancelButton = document.getElementById("modalDialogCancelButton");
		this.#cancelButton.addEventListener("click", () =&gt; this.#dialog.close("cancel"));
	}

	static get isOpen() {
		return this.#dialog.open;
	}

	static closeDialog(confirm) {
		if (this.isOpen)
			this.#dialog.close(confirm ? "confirm" : "cancel");
	}

	static async #showDialog(text, options) {

		const setupNameValuePairs = () =&gt; {
			const table = document.createElement("table");
			table.className = "modalDialogNameValueTable";
			const items = coerceArray(text);
			items.forEach(item =&gt; {
				let tr = document.createElement("tr");
				let td = document.createElement("td");
				td.innerText = item.key;
				tr.appendChild(td);
				td = document.createElement("td");
				if (item.isDifferent)
					td.className = "diffValue";
				td.innerText = item.value;
				tr.appendChild(td);
				table.appendChild(tr)
			});
			this.#dialogMessage.innerText = "";
			this.#dialogMessage.appendChild(table);
		}

		try {
			options = options ?? {};

			this.#dialog.classList.toggle("contentSize", options.useContentSize ?? true);

			const isInfo = options.noCancelButton === true;
			this.#dialogIconInformation.classList.toggle("hidden", !isInfo);
			this.#dialogIconConfirmation.classList.toggle("hidden", isInfo);

			this.#cancelButton.classList.toggle("hidden", isInfo);
			this.#dialogTitle.innerText = options.title ?? (isInfo ? "Information" : "Confirmation");

			if (options.isNameValuePairs)
				setupNameValuePairs()
			else {
				this.#dialogMessage.innerText = "";
				coerceArray(text).forEach(line =&gt; {
					const p = document.createElement("p");
					p.innerText = line;
					this.#dialogMessage.appendChild(p);
				});
			}

			this.#confirmButton.innerText = options.confirmButtonText ?? "Yes";
			this.#cancelButton.innerText = options.cancelButtonText ?? "No";
	        return new Promise((resolve) =&gt; {
	            this.#dialog.showModal();
				this.#dialog.addEventListener("close", e =&gt; {
					resolve(this.#dialog.returnValue === "confirm");
				}, { once: true });
	        });
		} catch (e) {
			handleError(e);
		}
	}

	static async showYesNo(text) {
		return this.show(text, {
			confirmButtonText: "Yes",
			cancelButtonText: "No"
		});
	}

	static async showOkCancel(text) {
		return this.show(text, {
			confirmButtonText: "Ok",
			cancelButtonText: "Cancel"
		});
	}

	static async showInfo(text) {
		return this.show(text, {
			confirmButtonText: "Ok",
			noCancelButton: true
		});
	}

	static async show(text, options) {
		return this.#showDialog(text, options);
	}
}

class PopupMenu {

	static async copyTextToClipboard(text, desc) {
		try {
			await navigator.clipboard.writeText(text);
			Toast.showInfoMessage(`${desc} was copied to the clipboard`)
		} catch (e) {
			console.error('Failed to copy: ', e);
		}
	}

	_menuElement

	_documentEventListeners;
	_keydownListenerId;


	constructor(menuElementId) {
		this._menuElement = document.getElementById(menuElementId);

		this._documentEventListeners = new DocumentEventListeners([
			{ eventName: "click", handler: this._documentClickHandler, groupName: "menuIsVisibleListenerGroup" }
		]);
	}

	_hideMenu() {
		this._menuElement.swapClass("block", "hidden", false);
		this._documentEventListeners.detach("menuIsVisibleListenerGroup");
		_documentKeydownHandler.removeListener(this._keydownListenerId);
	}

	_showMenu(x, y) {
		this._documentEventListeners.attach("menuIsVisibleListenerGroup");
		this._keydownListenerId = _documentKeydownHandler.addListener({
			key: KeyCodes.escape, action: "cancelMenu"}, this._keyDownHandler);

		const classNames = [...this._menuElement.classList].filter(name =&gt; name !== "hidden");
		classNames.push("block", "invisible");
		this._menuElement.className = classNames.join(" ");

		// keep menu on screen
		const popupWidth = this._menuElement.offsetWidth;
		const popupHeight = this._menuElement.offsetHeight;
		const windowWidth = window.innerWidth;
		const windowHeight = window.innerHeight;

		if (x + popupWidth &gt; windowWidth)
			x = windowWidth - popupWidth;
		if (y + popupHeight &gt; windowHeight)
			y = windowHeight - popupHeight;
		this._menuElement.style.left = `${x}px`;
		this._menuElement.style.top = `${y}px`;

		this._menuElement.classList.remove("invisible");
	}
	get isVisible() { return !this._menuElement.classList.contains("hidden"); }

	_keyDownHandler = (e, keyCode) =&gt; {
		switch (keyCode.action) {
			case "cancelMenu": {
				this._hideMenu();
				return true;
			}
		}
		return false;
	}

	_documentClickHandler = (e) =&gt; {
		if (this.isVisible &amp;&amp; !e.target.isDescendant(this._menuElement)) {
			e.preventDefault();
			this._hideMenu();
			return true;
		}
		return false;
	}

	show(menuItems, x, y) {
		if (this.isVisible) {
			this._hideMenu();
			return false;
		}

		var lastItem = null;
		menuItems = menuItems.filter(item =&gt; {
			if (item.type === "separator" &amp;&amp; lastItem &amp;&amp; lastItem.type === "separator")
				return false;
			lastItem = item;
			return true;
		});

		this._menuElement.innerText = "";
		const ul = document.createElement("ul");
		menuItems.forEach(item =&gt; {
			let li = document.createElement("li");
			if (item.type === "separator") {
				li.innerHTML = "&lt;hr/&gt;"
				li.className = "popup-menu-separator"
			} else {
				li.innerText = item.text;
				li.onclick = () =&gt; {
					this._hideMenu();
					if (item.handler)
						item.handler();
				};
			}
			ul.appendChild(li);
		});
		this._menuElement.appendChild(ul);

		this._showMenu(x, y);
		return true;
	}
}

class ContextMenu extends PopupMenu {

	#targetClassNames;
	#buildMenuItemsCallback;

	constructor(menuElementId, targetClassNames, buildMenuItemsCallback) {
		super(menuElementId);
		this.#targetClassNames = Array.isArray(targetClassNames) ? targetClassNames : targetClassNames.split(` +`);
		this.#buildMenuItemsCallback = buildMenuItemsCallback;

		this._documentEventListeners.add([
			{ eventName: "contextmenu", handler: this.#createContextMenuHandler, groupName: "createContextMenuListenerGroup" },
		]);
		this._documentEventListeners.attach("createContextMenuListenerGroup");
	}

	#createContextMenuHandler = (e) =&gt; {
		if (this.isVisible) {
			e.preventDefault();
			this._hideMenu();
			return;
		}

		const selector = `.${this.#targetClassNames.join(", .")}`;
		const element = e.target.closest(selector);
		if (!element) {
			if (!KeyCode.modifierKeysMatch({metaKey: true}, e)) {
				e.preventDefault();
				return true;
			}
			return;
		}

		const menuItems = this.#buildMenuItemsCallback(element);
		if (!menuItems) {
			console.log(`buildMenuItemsCallback returned null`);
			return;
		}

		e.preventDefault();

		this.show(menuItems, e.pageX, e.pageY);
	}
}

class Toast {
	static showInfoMessage(message, title, timeout) {
		this.showMessage({
			type: "success",
			title: title,
			message: message,
			displayTime: timeout ?? 4000
		});
	}

	static showMessage(options) {

		const querySelectorRequired = (element, selector) =&gt; {
			const result = element.querySelector(selector);
			if (result)
				return result;
			throw new Error(`Query Selector not found: "${selector}"`);
		}

		try {
			options.type = options.type ?? "success";
			options.canClose = options.canClose ?? true;
			options.showProgressBar = options.showProgressBar ?? false;
			options.displayTime = options.displayTime ?? 4000;
			options.title = options.title ?? options.type.toInitialCaps();

			const template = querySelectorRequired(document, "#toastTemplate");
			const toastElement = template.content.firstElementChild.cloneNode(true);

			// const schemes = ["success", "info", "warning"];
			const schemes = ["success"];
			if (schemes.includes(options.type)) {
				toastElement.classList.add(`toast-scheme-${options.type}`);
				schemes.forEach(scheme =&gt; {
					const icon = toastElement.querySelector(`.toast-icon-${scheme}`);
					icon.setHidden(scheme !== options.type);
				});
			} else
				throw new Error(`Invalid toast type: "${options.type}"`);

			querySelectorRequired(toastElement, ".toast-title-text").innerText = options.title;
			querySelectorRequired(toastElement, ".toast-message-text").innerText = options.message;

			const closeButtonElement = querySelectorRequired(toastElement, ".toast-close");
			const progressBarElement = querySelectorRequired(toastElement, ".toast-progress");

			closeButtonElement.setHidden(!options.canClose);
			progressBarElement.setHidden(!options.showProgressBar);

			document.body.prepend(toastElement);

			const close = () =&gt; {
				toastElement.classList.remove("toast-active");
				setTimeout(() =&gt; {
					toastElement.remove();
				}, 1000)
			}

			if (options.canClose)
				closeButtonElement.addEventListener("click", () =&gt; close());

			setTimeout(() =&gt; {
				toastElement.classList.add("toast-active");
				if (options.showProgressBar)
					progressBarElement.classList.add("toast-active");
				setTimeout(() =&gt; close(), options.displayTime);
			}, 100)
		} catch (e) {
			handleError(e);
		}
	}
}

class EditableDivController {

	#finishEditingCallback;
	#undoCallback;
	#keydownHandlerId;
	#ignoreDivBlur

	constructor(finishEditingCallback, undoCallback) {
		this.#finishEditingCallback = finishEditingCallback;
		this.#undoCallback = undoCallback;
	}

	beginEditingDiv(div) { this.#makeDivEditable(div, true); }
	endEditingDiv(div, acceptInput) { this.#finishEditingDiv(div, acceptInput); }
	isDivModified(div) { return div.classList.contains("modified"); }
	isDivEditing(div) { return div.classList.contains("editing"); }
	undoDivEdit(div) { if (this.#undoCallback) this.#undoCallback(div); }

	attachDiv(div, editButton, undoButton) {
		if (editButton)
			editButton.addEventListener("click", (e) =&gt; this.#editButtonClicked(e, div));
		if (undoButton &amp;&amp; this.#undoCallback)
			undoButton.addEventListener("click", (e) =&gt; this.#undoCallback(div, e));
	}

	#inputKeyDown = (e, keyCode) =&gt; {
		try {
			switch (keyCode.action) {
				case "finishEditing": {
					this.#finishEditingDiv(e.target, keyCode.acceptInput);
					return true;
				}
			}
			return false;
		} catch (e) {
			handleError(e);
		}
	}

	#editButtonClicked(e, div) {
		try {
			this.#makeDivEditable(div, true);
		} catch (e) {
			handleError(e);
		}
	}

	#inputFocused(e) {
		try {
			if (!this.#keydownHandlerId) {
				this.#keydownHandlerId = _documentKeydownHandler.addListener([
					{ key: KeyCodes.escape, action: "finishEditing", acceptInput: false },
					{ key: KeyCodes.enter, action: "finishEditing", acceptInput: true }
				], this.#inputKeyDown);
			}
		} catch (e) {
			handleError(e);
		}
	}

	#inputBlurred(e) {
		try {
			if (!this.#ignoreDivBlur)
				this.#finishEditingDiv(e.target, true);
		} catch (e) {
			handleError(e);
		}
	}

	#makeDivEditable(div, editable) {

		const otherDivsEditing = (div) =&gt; {
			const editingDivs = document.querySelectorAll(".editing");
			if (editingDivs.length === 0)
				return false;
			if (editingDivs.length &gt; 1)
				return true;
			return editingDivs[0] !== div;
		}

		if (otherDivsEditing(div))
			return;
		const content = div.querySelector(".editableDivContent");
		if (editable) {
			document.querySelectorAll(".editableDivContainer").forEach(ele =&gt; ele.classList.add("somethingsEditing"));
			const input = document.createElement("input");
			input.setAttribute("type", "text");
			input.setAttribute("spellcheck", false);
			input.addEventListener("focus", (e) =&gt; this.#inputFocused(e));
			input.addEventListener("blur", (e) =&gt; this.#inputBlurred(e));

			const a = content.querySelector("a");
			if (a)
				input.value = a.innerText;
			else
				input.value = content.innerText;
			content.classList.add("hidden");
			div.appendChild(input);
			div.classList.add("editing");
			setTimeout(() =&gt; {
				input.focus();
				input.setSelectionRange(0, 0);
			}, 100);
		} else {
			div.classList.remove("editing");
			const input = div.querySelector("input");
			div.removeChild(input);
			content.classList.remove("hidden");
			document.querySelectorAll(".editableDivContainer").forEach(ele =&gt; ele.classList.remove("somethingsEditing"));
			div.blur();
		}
	}

	#finishEditingDiv(div, acceptInput) {
		try {
			div = div.closest(".editableDiv");
			const text = div.querySelector("input").value;
			this.#ignoreDivBlur = true;
			this.#makeDivEditable(div, false);
			if (this.#keydownHandlerId) {
				_documentKeydownHandler.removeListener(this.#keydownHandlerId);
				this.#keydownHandlerId = null;
			}
			this.#finishEditingCallback(div, text, acceptInput);
		} catch (e) {
			handleError(e);
			throw e;
		} finally {
			this.#ignoreDivBlur = false;
		}
	}
}

var _tableController;

class TableController {
	#data;
	#editableMacroNameDivController;
	#editableGroupNameDivController;
	#importButton;
	#titleIconElement;
	#titleElement;
	#titleModifiedElement;
	#contextMenu;

	constructor() {
		try {
			this.#titleIconElement = document.getElementById("titleIcon");
			this.#titleElement = document.getElementById("title");
			this.#titleModifiedElement = document.getElementById("titleModified");
			this.#importButton = document.getElementById("importButton");
			this.#editableMacroNameDivController = new EditableDivController(
				(div, name, acceptInput) =&gt; this.#finishEditingNameDiv(div, name, acceptInput),
				(div, e) =&gt; this.#undoNameChange(div, e),
			);
			this.#editableGroupNameDivController = new EditableDivController(
				(div, name, acceptInput) =&gt; this.#finishEditingNameDiv(div, name, acceptInput),
				(div, e) =&gt; this.#undoNameChange(div, e)
			);
			this.#contextMenu = new ContextMenu("contextMenu", ["groupNameDiv", "macroNameDiv"], (element) =&gt; this.#buildContextMenu(element));

			this.#loadData();
			this.#buildTable();
		} catch (e) {
			handleError(e);
		}
	}

	get data() { return this.#data; }

	beginEditingGroupOrMacroDiv(div) { this.#getEditableDivController(div).beginEditingDiv(div); }
	endEditingGroupOrMacroDiv(div, acceptInput) { this.#getEditableDivController(div).endEditingDiv(div, acceptInput); }
	getMacroOrGroupNameForDiv(div) { return this.#getItemInfoForElement(div).item.name; }
	getMacroOrGroupUuidForDiv(div) { return this.#getItemInfoForElement(div).uuid; }
	isGroupOrMacroDivModified(div) { return this.#getIsDivModified(div); }
	isGroupOrMacroDivEditing(div) { return this.#getEditableDivController(div).isDivEditing(div); }
	undoGroupOrMacroDivEdit(div)  { this.#getEditableDivController(div).undoDivEdit(div); }

	#getEditableDivController(div) { return this.#getItemInfoForElement(div).type === "macro" ? this.#editableMacroNameDivController : this.#editableGroupNameDivController; }

	#loadData() {
		this.#data = KM.getJSONVariable("Local_ImportFileInfo", true);
		this.#titleElement.innerText = this.#data.fileName;
	}

	#buildTable() {

		const makeSvg = (id, size) =&gt; {
			const svgNS = "http://www.w3.org/2000/svg";
			const svg = document.createElementNS(svgNS, "svg");
			if (size) {
				svg.setAttribute("width", size);
				svg.setAttribute("height", size);
			}

			const use = document.createElementNS(svgNS, "use");
			use.setAttribute("href", `#${id}`);
			svg.appendChild(use);
			return svg;
		}

		const makeIconDiv = (iconFilePath) =&gt; {
			const iconDiv = document.createElement("div");
			iconDiv.className = "iconDiv";

			if (iconFilePath) {
				const img = document.createElement("img");
				img.className = "iconImg";
				img.src = iconFilePath;
				iconDiv.appendChild(img);
			} else {
				iconDiv.appendChild(makeSvg("commandIcon"));
			}

			return iconDiv;
		}

		const makeNameButton = (iconType) =&gt; {
			const nameButton = document.createElement("div");
			const prefix = iconType;
			nameButton.classList.add(`nameButton`);
			nameButton.classList.add(`${prefix}NameButton`);
			if (iconType !== "help")
				nameButton.classList.add(`nameButtonHidden`);

			const nameButtonContents = document.createElement("div");
			nameButtonContents.className = "nameButtonContents";
			nameButton.appendChild(nameButtonContents);

			var size;
			switch (iconType) {
				case "edit":
					size = "12";
					break;
				case "undo":
					size = "10";
					break;
				case "help":
					size = "11";
					break;
				default:
					throw new Error(`Invalid iconType: "${iconType}"`);
			}
			nameButtonContents.appendChild(makeSvg(`${prefix}Icon`, size));
			return nameButton;
		}

		const makeEditNameButton = () =&gt; {
			return makeNameButton("edit");
		}

		const makeUndoNameButton = () =&gt; {
			return makeNameButton("undo");
		}

		const makeHelpNameButton = (helpType) =&gt; {
			const result = makeNameButton("help");
			result.addEventListener("click", (e) =&gt; this.#helpButtonClicked(e, helpType));
			return result;
		}

		const makeCustomCheckbox = () =&gt; {
			const checkboxContainer = document.createElement("div");
			checkboxContainer.className = "custom-checkbox-container";
			const checkboxInput = document.createElement("input");
			checkboxInput.type = "checkbox";
			checkboxInput.className = "macroCheckbox custom-checkbox";
			checkboxInput.id = `checkbox${checkboxCounter++}`;
			checkboxInput.checked = true;
			checkboxInput.onchange = (e) =&gt; this.#checkboxChanged(e.target);
			checkboxContainer.appendChild(checkboxInput);

			const checkboxLabel = document.createElement("label");
			checkboxLabel.className = "custom-checkbox-label";
			checkboxLabel.setAttribute("for", checkboxInput.id);
			checkboxContainer.appendChild(checkboxLabel);
			return checkboxContainer;
		}

		var checkboxCounter = 1;
		const macroListContainer = document.getElementById("macroListContainer");
		macroListContainer.innerText = "";

		var firstGroup = true;
		this.#data.groupsInfo.forEach(group =&gt; {
			if (firstGroup) {
				firstGroup = false;
				if (group.iconFilePath) {
					this.#titleIconElement.appendChild(makeIconDiv(group.iconFilePath));
					this.#titleIconElement.setHidden(false);
				}
			}

			const groupItemContainer = document.createElement("div");
			groupItemContainer.className = "itemContainer groupItemContainer editableDivContainer";
			if (group.iconFilePath)
				groupItemContainer.appendChild(makeIconDiv(group.iconFilePath));

			const groupNameDiv = document.createElement("div");
			groupNameDiv.className = "groupNameDiv editableDiv";

			const groupNameDivContent = document.createElement("div");
			groupNameDivContent.className = "editableDivContent";
			groupNameDiv.appendChild(groupNameDivContent);

			this.#setNameDivText(groupNameDiv, group, groupNameDivContent);
			groupNameDiv.dataset.itemUuid = group.uuid;
			groupNameDiv.dataset.itemType = "group";
			groupItemContainer.appendChild(groupNameDiv);

			const groupEditNameButton = makeEditNameButton();
			groupItemContainer.appendChild(groupEditNameButton);
			const groupUndoNameButton = makeUndoNameButton();
			groupItemContainer.appendChild(groupUndoNameButton);
			this.#editableGroupNameDivController.attachDiv(groupNameDiv, groupEditNameButton, groupUndoNameButton);

			macroListContainer.appendChild(groupItemContainer);

			const ul = document.createElement("ul");
			ul.className = "checkbox-list";

			const macrosHaveIcons = group.macros.find(m =&gt; m.iconFilePath) != null;
			group.macros.forEach(macro =&gt; {
				const li = document.createElement("li");
				const itemDiv = document.createElement("div");
				itemDiv.className = "itemContainer macroItemContainer editableDivContainer";

				itemDiv.appendChild(makeCustomCheckbox());

				if (macrosHaveIcons)
					itemDiv.appendChild(makeIconDiv(macro.iconFilePath));

				const nameDiv = document.createElement("div");
				nameDiv.className = "macroNameDiv editableDiv";
				nameDiv.dataset.itemUuid = macro.uuid;
				nameDiv.dataset.itemType = "macro";

				const nameDivContent = document.createElement("div");
				nameDivContent.className = "editableDivContent";

				nameDiv.appendChild(nameDivContent);

				this.#setNameDivText(nameDiv, macro, nameDivContent);
				itemDiv.appendChild(nameDiv);

				if (macro.name === "undefined")
					itemDiv.appendChild(makeHelpNameButton("noname"));

				const editMacroNameButton = makeEditNameButton();
				itemDiv.appendChild(editMacroNameButton);
				const undoMacroNameButton = makeUndoNameButton();
				itemDiv.appendChild(undoMacroNameButton);
				this.#editableMacroNameDivController.attachDiv(nameDiv, editMacroNameButton, undoMacroNameButton);

				li.appendChild(itemDiv);
				ul.appendChild(li);
			});
			macroListContainer.appendChild(ul);
		});
	}

	#helpButtonClicked(e, helpType) {
		const helpMessages = {
			"noname": [
				`If a macro name is "undefined", that means the macro's name is actually blank.`,
				`If you looked at it in the Keyboard Maestro editor, if will show a name.`,
				`But that's because when the name is blank, KM infers the name from the first action in the macro.`,
				`I'm not 100% sure how to do this correctly, so I'm showing blank names as "undefined".`
			]
		}
		ModalDialogController.show((helpMessages[helpType]), {
			title: `"undefined" Macro Names`,
			confirmButtonText: "Ok",
			noCancelButton: true,
			useContentSize: false
		});
	}

	#showDivInfo(div) {
		const info = this.#getItemInfoForElement(div);
		const item = info.item;
		const lines = [
			{key: "Name", value: item.name},
			{key: "OrigName", value: item.origName, isDifferent: item.origName != item.name},
			{key: "UUID", value: item.uuid},
			{key: "OrigUUID", value: item.origUuid, isDifferent: item.origUuid != item.uuid},
			{key: "AlreadyExists", value: item.alreadyExists == null ? null : `${item.alreadyExists}`},
			{key: "OrigAlreadyExists", value: item.origAlreadyExists == null ? null : `${item.origAlreadyExists}`, isDifferent: item.origAlreadyExists != item.alreadyExists},
		].filter(line =&gt; line.value != null);

		ModalDialogController.show(lines, {
			isNameValuePairs: true,
			title: `${info.Type} Information`,
			noCancelButton: true,
			confirmButtonText: "OK"
		});
	}

	#buildContextMenu(element) {
		if (this.isGroupOrMacroDivEditing(element))
			return null;

		const itemInfo = this.#getItemInfoForElement(element);
		const item = itemInfo.item;
		const type = itemInfo.Type;

		const result = [];
		result.push({ text: `Get Info`, handler: () =&gt; this.#showDivInfo(element) });
		if (this.isGroupOrMacroDivModified(element))
			result.push({ text: `Undo ${type} Name Change`, handler: () =&gt; this.undoGroupOrMacroDivEdit(element) });
		result.push(
			{ text: `Edit ${type} Name`, handler: () =&gt; this.beginEditingGroupOrMacroDiv(element) },
			{ text: `Copy ${type} UUID`,
				handler: async () =&gt; {
					const uuid = this.getMacroOrGroupUuidForDiv(element);
					await PopupMenu.copyTextToClipboard(uuid, `The ${type} UUID`);
				}
			},
			{ text: `Copy ${type} Name`,
				handler: async () =&gt; {
					const name = this.getMacroOrGroupNameForDiv(element);
					await PopupMenu.copyTextToClipboard(name, `The ${type} Name`);
				}
			}
		);

		if (itemInfo.type === "group") {
			const checkedCount = item.macros.filter(macro =&gt; macro.includeInImport !== false).length;
			result.push({ type: "separator" });
			const macroListElement = element.closest(".groupItemContainer").nextSibling;
			if (checkedCount &lt; item.macros.length)
				result.push({ text: "Select all", handler: () =&gt; this.selectAll(true, macroListElement) });
			if (checkedCount &gt; 0)
				result.push({ text: "Unselect all", handler: () =&gt; this.selectAll(false, macroListElement) });
		}
		result.push(
			{ type: "separator" },
			{ text: `Copy ${type} XML to the Clipboard`, handler: () =&gt; this.#copyScriptToClipboard(itemInfo, "xml")},
			{ text: `Copy ${type} JSON to the Clipboard`, handler: () =&gt; this.#copyScriptToClipboard(itemInfo, "json")}
		);

		result.push({ type: "separator" });
		result.push({ text: `Open ${type} XML in Editor`, handler: () =&gt; this.#openScriptInEditor(itemInfo, "xml")});
		result.push({ text: `Open ${type} JSON in Editor`, handler: () =&gt; this.#openScriptInEditor(itemInfo, "json")});

		if (type === "Macro" &amp;&amp; item.alreadyExists) {
			result.push({ type: "separator" });
			result.push({ text: `Compare ${type} XML Scripts`, handler: () =&gt; this.#compareMacros(itemInfo, "xml")});
			result.push({ text: `Compare ${type} JSON Scripts`, handler: () =&gt; this.#compareMacros(itemInfo, "json")});
		}

		result.push(
			{ type: "separator" },
			{ text: "Cancel" }
		);
		return result;
	}

	#triggerCoreMacro(options) {
		const params = {
			localVariables: {
				WindowId: KM.getKMWindowId(),
				kmmacrosFilePath: this.#data.filePath
			},
			instanceVariables: {
				CoreFilePath: _coreFilePath
			}
		};

		for (const [key, value] of Object.entries(options)) {
			params.localVariables[key] = value;
		}
		KM.trigger(_coreMacroUuid, JSON.stringify(params, null, 2));
	}

	#copyScriptToClipboard(itemInfo, format) {
		try {
			this.#triggerCoreMacro({
				Action: "copyToClipboard",
				ItemUuid: itemInfo.item.origUuid ?? itemInfo.item.uuid,
				OutputFormat: format,
				NotifyMessage: `${itemInfo.Type} was copied to the clipboard as ${format.toUpperCase()}`
			});
		} catch (e) {
			handleError(e);
		}
	}

	#openScriptInEditor(itemInfo, format) {
		try {
			this.#triggerCoreMacro({
				Action: "openInEditor",
				ItemUuid: itemInfo.item.origUuid ?? itemInfo.item.uuid,
				OutputFormat: format
			});
		} catch (e) {
			handleError(e);
		}
	}

	#compareMacros(itemInfo, format) {
		try {
			this.#triggerCoreMacro({
				Action: "compareMacros",
				kmmacrosFilePath: this.#data.filePath,
				MacroUuid: itemInfo.item.origUuid ?? itemInfo.item.uuid,
				OutputFormat: format
			});
		} catch (e) {
			handleError(e);
		}
	}

	#getGroupItem(groupUuid, data) {
		data = data ?? this.#data;
		const groupInfo = data.groupsInfo.find(g =&gt; g.uuid === groupUuid);
		if (!groupInfo)
			throw new Error(`Could not find group info for group uuid "${groupUuid}"`);
		return groupInfo;
	}

	#getMacroItem(macroUuid, data, throwIfNotFound = true) {
		data = data ?? this.#data;
		for (let group of data.groupsInfo) {
			const macro = group.macros.find(m =&gt; m.uuid === macroUuid);
			if (macro)
				return macro;
		}
		if (throwIfNotFound)
			throw new Error(`Could not find macro info for macro uuid "${macroUuid}"`);
		return null;
	}

	#getCheckboxForMacroUuid(macroUuid) {
		const macroNameDiv = document.querySelector(`[data-item-uuid="${macroUuid}"]`);
		if (!macroNameDiv)
			throw new Error(`Could not find macroNameDiv for UUID "${macroUuid}"`);
		const container = macroNameDiv.closest(".macroItemContainer");
		if (!container)
			throw new Error(`Could not find the container for macro UUID "${macroUuid}"`);
		const checkbox = container.querySelector(".macroCheckbox");
		if (!checkbox)
			throw new Error(`Could not find the checkbox for macro UUID "${macroUuid}"`);
		return checkbox;
	}

	#getIsGroupRenamed(groupOrGroupUuid) {
		const group = typeof groupOrGroupUuid === "string" ? this.#getGroupItem(groupOrGroupUuid) : groupOrGroupUuid;
		return group.origName != null;
	}

	#getIsMacroRenamed(macroOrMacroUuid) {
		const macro = typeof macroOrMacroUuid === "string" ? this.#getMacroItem(macroOrMacroUuid) : macroOrMacroUuid;
		return macro.origName != null;
	}

	#getIsDivModified(div) {
		const item = this.#getItemInfoForElement(div).item;
		return item.origName != null;
	}

	#getIsModified() {
		for (let group of this.#data.groupsInfo) {
			if (this.#getIsGroupRenamed(group))
				return true;
			if (group.macros.find(m =&gt; {
				if (m.includeInImport === false)
					return true;
				return this.#getIsMacroRenamed(m);
			})) {
				return true;
			}
		}
		return false;
	}

	selectAll(select, containerElement) {
		containerElement = containerElement ?? document;
		containerElement.querySelectorAll(".macroCheckbox").forEach(chk =&gt; {
			chk.checked = select;
			this.#checkboxChanged(chk);
		});
		this.#somethingChanged();
	}

	#enableControlsTimerId;
	#somethingChanged() {

		const enableControls = () =&gt; {
			const checkboxes = Array.from(document.querySelectorAll(".macroCheckbox"));
			const somethingSelected = checkboxes.find(chk =&gt; chk.checked) != null;
			this.#importButton.classList.toggle("disabled", !somethingSelected);

			const isModified = this.#getIsModified();
			this.#titleModifiedElement.classList.toggle("hidden", !isModified);
		}

		if (!this.#enableControlsTimerId) {
			this.#enableControlsTimerId = setTimeout(() =&gt; {
				this.#enableControlsTimerId = null;
				enableControls()
			}, 1);
		}
	}

	selectReferencedMacros(uuids) {
		uuids.forEach(uuid =&gt; {
			const checkbox = this.#getCheckboxForMacroUuid(uuid);
			checkbox.checked = true;
			this.#checkboxChanged(checkbox);
		});
		this.#somethingChanged();
	}

	#findReferencedExcludedMacros(data) {

		const inspectUUID = (uuid =&gt; {
			if (inspectedUUIDs.includes(uuid))
				return;
			inspectedUUIDs.push(uuid);
			const macro = flattenedMacros.find(m =&gt; m.uuid === uuid);
			if (!macro.includeInImport &amp;&amp; !macro.alreadyExists)
				referencedExcludedUUIDs.push(uuid);
			if (macro.referencedMacros)
				macro.referencedMacros.forEach(refUUID =&gt; inspectUUID(refUUID));
		});

		const flattenedMacros = data.groupsInfo.flatMap(g =&gt; g.macros);
		const includedMacroUUIDs = flattenedMacros.filter(m =&gt; m.includeInImport).map(m =&gt; m.uuid);
		const inspectedUUIDs = [];
		const referencedExcludedUUIDs = [];
		includedMacroUUIDs.forEach(uuid =&gt; inspectUUID(uuid));

		console.log(`referencedExcludedUUIDs:\n${referencedExcludedUUIDs.join("\n")}`);

		return referencedExcludedUUIDs.length &gt; 0 ? referencedExcludedUUIDs : null;
	}

	getResults() {
		try {
			const results = deepClone(this.#data);

			var includedGroupsCount = 0;
			var includedMacrosCount = 0;
			var isModified = false;
			results.groupsInfo.forEach(group =&gt; {
				var macroCount = 0;
				group.macros.forEach(macro =&gt; {
					macro.includeInImport = macro.includeInImport ?? true;
					if (macro.includeInImport) {
						macroCount++;
						if (macro.origName)
							isModified = true;
					} else {
						isModified = true;
					}
				});
				group.includeInImport = macroCount &gt; 0;
				if (group.includeInImport) {
					includedGroupsCount++;
					includedMacrosCount += macroCount;
					if (group.origName)
						isModified = true;
				} else {
					isModified = true;
				}
			});

			results.summary = `${includedMacrosCount} Macro${includedMacrosCount &gt; 1 ? "s" : ""} in ${includedGroupsCount} Group${includedGroupsCount &gt; 1 ? "s" : ""}`;
			results.modified = isModified;
			results.referencedExcludedMacros = this.#findReferencedExcludedMacros(results);
			return results;
		} catch (e) {
			handleError(e);
		}
	}

	#getItemInfoForElement(ele, expectedItemType) {
		if (!ele.dataset.itemType) {
			const container = ele.closest(".itemContainer");
			if (!container)
				throw new Error(`Could not find closest itemContainer`);
			ele = container.querySelector(`[data-item-uuid]`);
			if (!ele)
				throw new Error(`Could not find item with "data-item-uuid"`);
		}
		if (expectedItemType &amp;&amp; ele.dataset.itemType !== expectedItemType)
			throw new Error(`getItemInfoForElement expected to find itemType "${expectedItemType}", found "${ele.dataset.itemType}"`);
		const result = {
			type: ele.dataset.itemType,
			Type: ele.dataset.itemType.toInitialCaps(),
			uuid: ele.dataset.itemUuid,
			element: ele
		};
		result.item = result.type === "group" ? this.#getGroupItem(result.uuid) : this.#getMacroItem(result.uuid);
		return result;
	}

	#checkboxChanged(checkbox) {
		try {
			const macro = this.#getItemInfoForElement(checkbox, "macro").item;
			macro.includeInImport = checkbox.checked;
			this.#somethingChanged();
		} catch (e) {
			handleError(e);
		}
	}

	#setNameDivText(nameDiv, groupOrMacro, nameDivContent) {
		if (!nameDivContent)
			nameDivContent = nameDiv.querySelector(".editableDivContent");
		if (groupOrMacro.alreadyExists) {
			nameDivContent.innerText = "";
			let a = document.createElement("a");
			a.text = groupOrMacro.name;
			a.href = `keyboardmaestro://m=${groupOrMacro.uuid}`;
			nameDivContent.appendChild(a);
			nameDivContent.classList.remove("noLink");
		} else {
			nameDivContent.innerText = groupOrMacro.name;
			nameDivContent.classList.add("noLink");
		}
	}

	#finishEditingNameDiv(nameDiv, name, acceptInput) {
		try {
			name = name.trim();
			const itemInfo = this.#getItemInfoForElement(nameDiv);
			const item = itemInfo.item;
			if (itemInfo.element !== nameDiv)
				throw new Error(`Logic error: Expected itemInfo.element to equal nameDiv`);
			if (acceptInput &amp;&amp; name &amp;&amp; name !== item.name) {
				if (name === item.origName) {
					item.name = item.origName;
					item.origName = null;
					if (itemInfo.type === "group") {
						item.uuid = item.origUuid;
						item.origUuid = null;
						item.alreadyExists = item.origAlreadyExists;
						item.origAlreadyExists = null;
					}
				} else {
					if (!item.origName) {
						item.origName = item.name;
						if (itemInfo.type === "group") {
							item.origUuid = item.uuid;
							item.origAlreadyExists = item.alreadyExists;
							if (item.alreadyExists) {
								item.uuid = KM.getNewUUID();
								item.alreadyExists = false;
							}
						}
					}
					item.name = name;
				}
			}
			nameDiv.dataset.itemUuid = item.uuid;
			this.#setNameDivText(nameDiv, item);
			nameDiv.classList.toggle("modified", item.origName != null);
			this.#somethingChanged();
		} catch (e) {
			handleError(e);
		}
	}

	#undoNameChange(nameDiv, e) {
		try {
			const item = this.#getItemInfoForElement(nameDiv).item;
			if (!item.origName)
				throw new Error(`No origName in undoNameChange`);
			this.#finishEditingNameDiv(nameDiv, item.origName, true);
		} catch (e) {
			handleError(e);
		}
	}
}

class TextWidthCalculator {

	static execute(element, text) {
		return (new TextWidthCalculator(element)).calcTextWidth(text ?? element.innerText);
	}

	#context;

	constructor(element) {
		const canvas = document.createElement("canvas");
		this.#context = canvas.getContext("2d");
		this.#context.font = window.getComputedStyle(element).font;
	}

	calcTextWidth(text) {
		if (!text)
			return 0;
		var result = 0;
		if (!Array.isArray(text))
			text = [text];
		text.forEach(entry =&gt; {
			const width = Math.ceil(this.#context.measureText(entry).width);
			result = Math.max(result, width);
		});
		return result;
	}
}

var _wdc;
class WindowDimensionController {
	#screenLeft;
	#screenTop;
	#screenWidth;
	#screenHeight;
	#midScreenX;
	#midScreenY;
	#maxWindowWidth;
	#maxWindowHeight;

	constructor() {
		const screenBounds = KM.getVariable("Instance_ScreenBounds").trim();
		if (screenBounds) {
			const bounds = parseBoundsString(screenBounds, "Instance_ScreenBounds");
			this.#screenLeft = bounds.left;
			this.#screenTop = bounds.top;
			this.#screenWidth = bounds.width;
			this.#screenHeight = bounds.height;
		} else {
			this.#screenLeft = KM.screenLeft;
			this.#screenTop = KM.screenTop;
			this.#screenWidth = KM.screenWidth;
			this.#screenHeight = KM.screenHeight;
		}

		this.#midScreenX = Math.floor(this.#screenLeft + (this.#screenWidth / 2));
		this.#midScreenY = Math.floor(this.#screenTop + (this.#screenHeight / 2));

		var maxWindowWidth = KM.getIntVariable("Instance_MaxWindowWidth", false);
		if (!maxWindowWidth)
			maxWindowWidth = KM.getIntVariable("Local_MaxWindowWidth", false, {defaultValue: this.#screenWidth});
		this.#maxWindowWidth = Math.min(this.#screenWidth, maxWindowWidth);

		var maxWindowHeight = KM.getIntVariable("Instance_MaxWindowHeight", false);
		if (!maxWindowHeight)
			maxWindowHeight = KM.getIntVariable("Local_MaxWindowHeight", false, {defaultValue: this.#screenHeight});
		this.#maxWindowHeight = Math.min(this.#screenHeight, maxWindowHeight);
	}

	get screenLeft() { return this.#screenLeft; }
	get screenTop() { return this.#screenTop; }
	get screenWidth() { return this.#screenWidth; }
	get screenHeight() { return this.#screenHeight; }
	get midScreenX() { return this.#midScreenX; }
	get midScreenY() { return this.#midScreenY; }
	get maxWindowWidth() { return this.#maxWindowWidth; }
	get maxWindowHeight() { return this.#maxWindowHeight; }
}

class WindowPositionController {

	static #calcBestHeight() {
		const clientContainer = document.getElementById("clientContainer");
		const bestClientContainerHeight = clientContainer.getBoundingClientRect().height;
		clientContainer.swapClass("client-container", "client-container-startup", true);
		const recommendedHeight = document.querySelector("header").getBoundingClientRect().height
			+ bestClientContainerHeight
			+ document.querySelector("footer").getBoundingClientRect().height
			+ 20;

		// const h1 = Math.max(360, Math.min(_wdc.screenHeight - 40, recommendedHeight));
		const h1 = Math.max(360, Math.min(_wdc.screenHeight, recommendedHeight));
		return Math.min(_wdc.maxWindowHeight, h1);
	}

	static #calcBestWidth() {
		const titleWidth = TextWidthCalculator.execute(document.getElementById("title"));
		const modifiedTextWidth = TextWidthCalculator.execute(document.getElementById("titleModified"));

		const calculator = new TextWidthCalculator(document.getElementById("macroListContainer"));
		var maxMacroNameWidth = 0;
		var maxGroupNameWidth = 0;
		_tableController.data.groupsInfo.forEach(group =&gt; {
			const groupNameWidth = calculator.calcTextWidth(group.name);
			maxGroupNameWidth = Math.max(maxGroupNameWidth, groupNameWidth);
			group.macros.forEach(macro =&gt; {
				if (!/(.)\1{4,}/.test(macro.name)) {
					const macroNameWidth = calculator.calcTextWidth(macro.name);
					maxMacroNameWidth = Math.max(maxMacroNameWidth, macroNameWidth);
				}
			});
		});
		maxGroupNameWidth += 100;
		maxMacroNameWidth += 160;
		const w = Math.min(_wdc.maxWindowWidth, Math.max(titleWidth + modifiedTextWidth + 70, Math.max(maxGroupNameWidth, maxMacroNameWidth)));
		return Math.max(600, w);
	}

	static getStartupWindowBounds() {
		const width = this.#calcBestWidth();
		const height = this.#calcBestHeight() - 19;
		const parts = [
			Math.floor(_wdc.midScreenX - (width / 2)),
			Math.floor(_wdc.midScreenY - (height / 2)),
			width,
			height
		];
		const result = parts.join(",");
		return result;
	}

	static KM_getCurrentPosition() {
		const result = {
			filePath: _tableController.data.filePath,
			position: `${KM.windowLeft},${KM.windowTop + 19},${KM.windowWidth},${KM.windowHeight - 19}`
		};
		return JSON.stringify(result, null, 2);
	}

	static KM_setCurrentPosition(pos) {
		window.KeyboardMaestro.ResizeWindow(pos);
	}
}

function notifyFromKM(msg) {
	setTimeout(() =&gt; Toast.showInfoMessage(msg), 100);
}

var _coreMacroUuid;
var _coreFilePath;

function KMWindow() {

	function assignEventHandler(id, name, handler) {
		document.getElementById(id).addEventListener(name, handler);
	}

	function setupUI() {
		_documentKeydownHandler = new DocumentKeydownHandler();
		_tableController = new TableController();
		assignEventHandler("selectAllButton", "click", (event) =&gt; _tableController.selectAll(true));
		assignEventHandler("unselectAllButton", "click", (event) =&gt; _tableController.selectAll(false));
		assignEventHandler("cancelButton", "click", () =&gt; KM.close("cancel"));
		assignEventHandler("importButton", "click", async () =&gt; saveResults());
	}

	try {
		_wdc = new WindowDimensionController();
		_coreMacroUuid = KM.getVariable("Instance_Settings_MacroUUID_Core", true);
		_coreFilePath = KM.getVariable("Instance_CoreFilePath");
		setupUI();
		return WindowPositionController.getStartupWindowBounds();
	} catch (e) {
		handleError(e);
	}
}

function KMDidShowWindow() {
	_documentKeydownHandler.attach();
	ModalDialogController.attach();
}

function KMWillCloseWindow() {
}

async function saveResults() {
	try {
		const results = _tableController.getResults();

		if (results.referencedExcludedMacros) {
			let msgLines = [
				`The included macro(s) reference one or more excluded macros.`,
				`Do you want to include the referenced macros?`,
				`If you're not sure, click "Yes" and watch what happens.`
			];
			if (await ModalDialogController.showYesNo(msgLines)) {
				setTimeout(() =&gt; _tableController.selectReferencedMacros(results.referencedExcludedMacros));
				return;
			}
		}

		const msgLines = [];
		if (results.modified) {
			msgLines.push(`Ready to import ${results.summary}.`);
			msgLines.push(`The modified .kmmacros data will be written to a temp file.`);
			msgLines.push(`Click "OK" to import the the temp file.`);
		} else {
			msgLines.push(`Click "OK" to import everything from the .kmmacros file.`);
		}

		msgLines.push(`The Import process will start immediately after you click "OK.`);
		if (await ModalDialogController.showOkCancel(msgLines))
			KM.close(JSON.stringify(results, null, 2));
	} catch (e) {
		handleError(e);
	}
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body data-kmwindowid="MIMPrompt"&gt;
	&lt;template id="toastTemplate"&gt;
		&lt;div class="toast"&gt;
			&lt;div class="toast-content"&gt;
				&lt;svg class="toast-icon-success" width="18" height="18" enable-background="new 0 0 64 64" version="1.1" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg"&gt;
					&lt;path d="m9 0c-4.9704 0-9 4.0296-9 9s4.0296 9 9 9 9-4.0296 9-9-4.0296-9-9-9m1.5 14.925h-3v-7.2h3v7.2m-1.5-8.85c-0.8283 0-1.5-0.6714-1.5-1.5s0.6717-1.5 1.5-1.5c0.8286 0 1.5 0.6714 1.5 1.5s-0.6714 1.5-1.5 1.5" fill="#43a047" stroke-width=".3"/&gt;
				&lt;/svg&gt;
				&lt;!-- &lt;img class="toast-icon-info" src="../../assets/images/green-info-circle.svg"&gt;
				&lt;img class="toast-icon-warning" src="../../assets/images/warning-triangle.svg"&gt; --&gt;

				&lt;div class="toast-message"&gt;
					&lt;span class="toast-text toast-title-text"&gt;Success&lt;/span&gt;
					&lt;span class="toast-text toast-message-text"&gt;Your changes has been saved&lt;/span&gt;
				&lt;/div&gt;
			&lt;/div&gt;
			&lt;i class="toast-close"&gt;&lt;/i&gt;
			&lt;div class="toast-progress"&gt;&lt;/div&gt;
		&lt;/div&gt;
	&lt;/template&gt;
	&lt;dialog id="modalDialog" class="contentSize"&gt;
		&lt;div id="modalDialogContainer"&gt;
			&lt;div id="modalDialogHeader"&gt;
				&lt;div id="modalDialogIcon_information" class="modalDialogIcon hidden"&gt;💡&lt;/div&gt;
				&lt;div id="modalDialogIcon_confirmation"class="modalDialogIcon"&gt;❓&lt;/div&gt;
				&lt;div id="modalDialogTitle"&gt;Confirmation&lt;/div&gt;
			&lt;/div&gt;
			&lt;div id="modalDialogMessage"&gt;Are you sure?&lt;/div&gt;
			&lt;div class="modalDialogFooter"&gt;
				&lt;a id="modalDialogCancelButton" href="#" class="button cancelButton"&gt;Cancel&lt;/a&gt;
				&lt;a id="modalDialogConfimButton" href="#" class="button acceptButton"&gt;Import&lt;/a&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/dialog&gt;
	&lt;div id="contextMenu" class="popup-menu hidden"&gt;&lt;/div&gt;
	&lt;header id="documentHeader"&gt;
		&lt;div class="spacer"&gt;&lt;/div&gt;
		&lt;div id="titleGroup"&gt;
			&lt;div id="titleIcon" class="hidden"&gt;&lt;/div&gt;
			&lt;div id="title"&gt;&lt;/div&gt;
			&lt;div id="titleModified" class="hidden"&gt;(modified)&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class="spacer"&gt;&lt;/div&gt;
	&lt;/header&gt;
	&lt;div id="clientContainer" class="client-container-startup"&gt;
		&lt;svg style="display: none;"&gt;
			&lt;symbol id="editIcon" width="16" height="16" fill="blue" class="editIcon" viewBox="0 0 16 16"&gt;
				&lt;path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z" /&gt;
				&lt;path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5z" /&gt;
			&lt;/symbol&gt;
			&lt;symbol id="undoIcon" width="16" height="16" fill="blue" class="undoIcon" viewBox="0 0 50 50"&gt;
				&lt;path d="m9.1999 11.987c0.93452-1.6007 3.3979-3.5832 4.9612-4.624 7.1866-4.7819 16.874-4.6027 23.895 0.41512 4.2615 3.0445 7.2959 7.5804 8.3823 12.714 0.47182 2.2264 0.45157 3.6338 0.42626 5.8724-0.03544 2.9868-1.3486 6.8717-2.8754 9.4161-1.7789 2.9656-4.1785 5.4755-7.1481 7.2696-3.487 2.106-7.0793 3.0577-11.137 3.0577v-6.5811c2.6851 0 5.1879-0.68039 7.4924-2.0705 2.0655-1.2454 3.6702-2.8856 4.9561-4.9156 3.8231-6.0374 2.3976-13.864-2.9311-18.499-4.6483-4.0438-11.165-4.6858-16.503-1.6341-1.219 0.6976-2.8319 1.8862-3.6449 3.0223l1.7212 0.89604 3.7462 2.1414v0.2025l-4.1512 2.3874-7.8973 4.54-3.4424 1.9976s-1.9237 0.99729-1.9237 0.99729v-20.047l2.3287 1.2302z"/&gt;
			&lt;/symbol&gt;
			&lt;symbol id="helpIcon" width="16" height="16" fill="green" class="helpIcon" viewBox="0 0 16 16"&gt;
				&lt;path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0M5.496 6.033h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286a.237.237 0 0 0 .241.247m2.325 6.443c.61 0 1.029-.394 1.029-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94 0 .533.425.927 1.01.927z"/&gt;
			&lt;/symbol&gt;
			&lt;symbol id="commandIcon" width="20" height="20" fill="#7a82f7" class="commandIcon" viewBox="0 0 20 20"&gt;
				&lt;path d="m5.5 4a1.5 1.5 0 0 1 1.5 1.5v1.5h-1.5a1.5 1.5 0 1 1 0-3m2.5 3v-1.5a2.5 2.5 0 1 0-2.5 2.5h1.5v4h-1.5a2.5 2.5 0 1 0 2.5 2.5v-1.5h4v1.5a2.5 2.5 0 1 0 2.5-2.5h-1.5v-4h1.5a2.5 2.5 0 1 0-2.5-2.5v1.5zm4 1v4h-4v-4zm1-1v-1.5a1.5 1.5 0 1 1 1.5 1.5zm0 6h1.5a1.5 1.5 0 1 1-1.5 1.5zm-6 0v1.5a1.5 1.5 0 1 1-1.5-1.5z" stroke="#7a82f7"/&gt;
			&lt;/symbol&gt;
		&lt;/svg&gt;
		&lt;div id="macroListContainer"&gt;
		&lt;/div&gt;
	&lt;/div&gt;
	&lt;footer id="documentFooter"&gt;
		&lt;a id="selectAllButton" href="#" class="button"&gt;Select All&lt;/a&gt;
		&lt;a id="unselectAllButton" href="#" class="button"&gt;Unselect All&lt;/a&gt;
		&lt;div id="tipSpacer" class="spacer"&gt;Tip: Right-click on items for context menu&lt;/div&gt;
		&lt;a id="cancelButton" href="#" class="button cancelButton"&gt;Cancel&lt;/a&gt;
		&lt;a id="importButton" href="#" class="button acceptButton"&gt;Import&lt;/a&gt;
	&lt;/footer&gt;
&lt;/body&gt;

&lt;/html&gt;</string>
						<key>TimeOutAbortsMacro</key>
						<true/>
						<key>UseText</key>
						<true/>
					</dict>
				</array>
				<key>IsDisclosed</key>
				<false/>
				<key>MacroActionType</key>
				<string>IfThenElse</string>
				<key>ThenActions</key>
				<array>
					<dict>
						<key>ActionName</key>
						<string>MIM - Prompt.html</string>
						<key>ActionUID</key>
						<integer>16273586</integer>
						<key>Floating</key>
						<true/>
						<key>IsDisclosed</key>
						<false/>
						<key>MacroActionType</key>
						<string>CustomPrompt</string>
						<key>Path</key>
						<string>%Variable%Instance_HtmlFilePath%</string>
						<key>Resizable</key>
						<true/>
						<key>TimeOutAbortsMacro</key>
						<true/>
						<key>UseText</key>
						<false/>
					</dict>
				</array>
				<key>TimeOutAbortsMacro</key>
				<true/>
			</dict>
			<dict>
				<key>ActionUID</key>
				<integer>15817996</integer>
				<key>IsDisclosed</key>
				<false/>
				<key>MacroActionType</key>
				<string>SetVariableToText</string>
				<key>Text</key>
				<string>%HTMLResult%</string>
				<key>Variable</key>
				<string>Local_HTMLResult</string>
			</dict>
			<dict>
				<key>ActionColor</key>
				<string>Yellow</string>
				<key>ActionUID</key>
				<integer>15817933</integer>
				<key>CaseEntries</key>
				<array>
					<dict>
						<key>Actions</key>
						<array>
							<dict>
								<key>ActionColor</key>
								<string>Magenta</string>
								<key>ActionUID</key>
								<integer>16275605</integer>
								<key>Asynchronously</key>
								<false/>
								<key>IsDisclosed</key>
								<false/>
								<key>MacroActionType</key>
								<string>ExecuteMacro</string>
								<key>MacroUID</key>
								<string>0E494E6D-A9EC-47A1-BFF3-8B461FE34E94</string>
								<key>TimeOutAbortsMacro</key>
								<true/>
								<key>UseParameter</key>
								<true/>
							</dict>
							<dict>
								<key>Action</key>
								<string>CancelThisMacro</string>
								<key>ActionUID</key>
								<integer>15817978</integer>
								<key>IsDisclosed</key>
								<false/>
								<key>MacroActionType</key>
								<string>Cancel</string>
							</dict>
						</array>
						<key>ConditionType</key>
						<string>IsEmpty</string>
						<key>TestValue</key>
						<string>
^(cancel)?$</string>
					</dict>
					<dict>
						<key>Actions</key>
						<array>
							<dict>
								<key>ActionColor</key>
								<string>Magenta</string>
								<key>ActionUID</key>
								<integer>16275606</integer>
								<key>Asynchronously</key>
								<false/>
								<key>IsDisclosed</key>
								<false/>
								<key>MacroActionType</key>
								<string>ExecuteMacro</string>
								<key>MacroUID</key>
								<string>0E494E6D-A9EC-47A1-BFF3-8B461FE34E94</string>
								<key>TimeOutAbortsMacro</key>
								<true/>
								<key>UseParameter</key>
								<true/>
							</dict>
							<dict>
								<key>Action</key>
								<string>CancelThisMacro</string>
								<key>ActionUID</key>
								<integer>15817934</integer>
								<key>IsDisclosed</key>
								<false/>
								<key>MacroActionType</key>
								<string>Cancel</string>
							</dict>
						</array>
						<key>ConditionType</key>
						<string>Is</string>
						<key>TestValue</key>
						<string>cancel</string>
					</dict>
					<dict>
						<key>Actions</key>
						<array>
							<dict>
								<key>ActionColor</key>
								<string>Magenta</string>
								<key>ActionUID</key>
								<integer>16275607</integer>
								<key>Asynchronously</key>
								<false/>
								<key>IsDisclosed</key>
								<false/>
								<key>MacroActionType</key>
								<string>ExecuteMacro</string>
								<key>MacroUID</key>
								<string>0E494E6D-A9EC-47A1-BFF3-8B461FE34E94</string>
								<key>TimeOutAbortsMacro</key>
								<true/>
								<key>UseParameter</key>
								<true/>
							</dict>
							<dict>
								<key>ActionColor</key>
								<string>Magenta</string>
								<key>ActionUID</key>
								<integer>16271604</integer>
								<key>IsDisclosed</key>
								<false/>
								<key>MacroActionType</key>
								<string>ExecuteSubroutine</string>
								<key>MacroUID</key>
								<string>D4EDFECF-FCA5-432A-8E70-7F34CB30A4D4</string>
								<key>Parameters</key>
								<array>
									<string>%ExecutingMacro%</string>
									<string>%Variable%Local_HTMLResult%</string>
									<string>1</string>
								</array>
								<key>ResultVariable</key>
								<string>VarName</string>
								<key>TimeOutAbortsMacro</key>
								<true/>
							</dict>
						</array>
						<key>ConditionType</key>
						<string>Matches</string>
						<key>TestValue</key>
						<string>^Error:</string>
					</dict>
					<dict>
						<key>Actions</key>
						<array>
							<dict>
								<key>ActionColor</key>
								<string>Magenta</string>
								<key>ActionUID</key>
								<integer>16275608</integer>
								<key>Asynchronously</key>
								<false/>
								<key>IsDisclosed</key>
								<false/>
								<key>MacroActionType</key>
								<string>ExecuteMacro</string>
								<key>MacroUID</key>
								<string>0E494E6D-A9EC-47A1-BFF3-8B461FE34E94</string>
								<key>TimeOutAbortsMacro</key>
								<true/>
								<key>UseParameter</key>
								<true/>
							</dict>
							<dict>
								<key>ActionColor</key>
								<string>Magenta</string>
								<key>ActionUID</key>
								<integer>16271605</integer>
								<key>IsDisclosed</key>
								<false/>
								<key>MacroActionType</key>
								<string>ExecuteSubroutine</string>
								<key>MacroUID</key>
								<string>D4EDFECF-FCA5-432A-8E70-7F34CB30A4D4</string>
								<key>Parameters</key>
								<array>
									<string>%ExecutingMacro%</string>
									<string>Unknown HTML Result: "%Variable%Local_HTMLResult%"</string>
									<string>1</string>
								</array>
								<key>ResultVariable</key>
								<string>VarName</string>
								<key>TimeOutAbortsMacro</key>
								<true/>
							</dict>
						</array>
						<key>ConditionType</key>
						<string>DoesNotMatch</string>
						<key>TestValue</key>
						<string>^\{</string>
					</dict>
				</array>
				<key>IsDisclosed</key>
				<false/>
				<key>MacroActionType</key>
				<string>Switch</string>
				<key>Source</key>
				<string>Variable</string>
				<key>Variable</key>
				<string>Local_HTMLResult</string>
			</dict>
			<dict>
				<key>ActionUID</key>
				<integer>15817963</integer>
				<key>IsDisclosed</key>
				<false/>
				<key>MacroActionType</key>
				<string>Return</string>
				<key>Text</key>
				<string>%Variable%Local_HTMLResult%</string>
			</dict>
		</array>
		<key>CreationDate</key>
		<real>743902858.56974697</real>
		<key>ModificationDate</key>
		<real>753623662.06603801</real>
		<key>Name</key>
		<string>µ MIM - Prompt</string>
		<key>Triggers</key>
		<array>
			<dict>
				<key>MacroTriggerType</key>
				<string>Subroutine</string>
				<key>Parameters</key>
				<array>
					<string>Local_ImportFileInfo</string>
					<string>Local_MaxWindowHeight</string>
				</array>
				<key>ReturnsValue</key>
				<true/>
			</dict>
		</array>
		<key>UID</key>
		<string>7542F7E7-80E3-4788-807B-D319D089B821</string>
	</dict>
</array>
</plist>
